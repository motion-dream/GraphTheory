import java.util.Scanner;
/**
 * Author 1: MirrorML
 * Date: November 21, 2023
 * Author 2: ZYH
 * Date: November 27, 2023
 */
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String answer="n";
        do {
            System.out.print("Please input the number of nodes:");
            int V = scanner.nextInt();
            System.out.print("Please input the number of edges:");
            int E = scanner.nextInt();
            int[][] matrix = new int[V][V];
            System.out.println("Please input the graph(adjacency matrix):");
            for (int i = 0; i < V; i++) {
                for (int j = 0; j < V; j++) {
                    matrix[i][j] = scanner.nextInt();
                }
            }

            System.out.println("Choose the algorithm: \n" +
                    "\t  1: Kruskal\n" +
                    "\t  2: Prim\n" +
                    "\t  3: Bellman-Ford\n" +
                    "\t  4: Dijkstra\n" +
                    "\t  5: Hungarian\n" +
                    "\t  6: HopcroftKarp\n");
            int choice = scanner.nextInt();

            if (choice == 1) {
                KruskalAlgorithm.V = V;
                System.out.println("The result about a minimum spanning tree generated by the Kruskal's algorithm:");
                KruskalAlgorithm.kruskal(matrix);
            } else if (choice == 2) {
                PrimAlgorithm.V = V;
                System.out.println("The result about a minimum spanning tree generated by the Prim's algorithm:");
                PrimAlgorithm.primMST(matrix);
            } else if(choice == 3){
                System.out.print("Please input the startVertex of nodes:");
                int startVertex = scanner.nextInt();
                System.out.println("The result generated about the shortest path by the Bellman-Ford algorithm:");
                BellmanFordAlgorithm.bellmanFord(matrix, startVertex);
            }else if(choice == 4){
                System.out.print("Please input the startVertex of nodes:");
                int startVertex = scanner.nextInt();
                System.out.println("The result generated about the shortest path by the Dijkstra algorithm:");
                DijkstraAlgorithm.dijkstra(matrix, startVertex);
            }else if(choice == 5){
                System.out.print("Is the current input graph a bipartite graph?(y/n)");
                String flag = scanner.next();
                if(flag.equals("Y")){
                    int maxMatching = HungarianAlgorithm.maxMatching(matrix);
                    System.out.println("The maximum matching of the Hungarian algorithm: " + maxMatching);
                }else {
                    System.out.print("Please again input the number of nodes:");
                    V = scanner.nextInt();
                    matrix = new int[V][V];
                    System.out.println("Please again input the graph(adjacency matrix):");
                    for (int i = 0; i < V; i++) {
                        for (int j = 0; j < V; j++) {
                            matrix[i][j] = scanner.nextInt();
                        }
                    }
                    int maxMatching = HungarianAlgorithm.maxMatching(matrix);
                    System.out.println("The maximum matching of the Hungarian algorithm: " + maxMatching);
                }
            }else if(choice == 6){
                System.out.print("Is the current input graph a bipartite graph?(y/n)");
                String flag = scanner.next();
                if(flag.equals("Y")){
                    HopcroftKarpAlgorithm h = new HopcroftKarpAlgorithm(V,V);
                    h.setAdjMatrix(matrix);
                    int maxMatching = h.hopcroftKarpAlgorithm();
                    System.out.println("The maximum matching of the HopcroftKarp algorithm: " + maxMatching);
                }else {
                    System.out.print("Please again input the number of nodes:");
                    V = scanner.nextInt();
                    matrix = new int[V][V];
                    System.out.println("Please again input the graph(adjacency matrix):");
                    for (int i = 0; i < V; i++) {
                        for (int j = 0; j < V; j++) {
                            matrix[i][j] = scanner.nextInt();
                        }
                    }
                    HopcroftKarpAlgorithm h = new HopcroftKarpAlgorithm(V,V);
                    h.setAdjMatrix(matrix);
                    int maxMatching = h.hopcroftKarpAlgorithm();
                    System.out.println("The maximum matching of the HopcroftKarp algorithm: " + maxMatching);
                }
            }else {
                System.out.println("Invalid choice");
            }
            System.out.println("Do you want continue?(y/n)");
            answer=scanner.next();
        }while(answer.equals("y"));
        System.out.println("Over!");


        /*
//        1.采用一条条输入的方式，废弃 2.所有算法依次执行，废弃
        while (true){
            Scanner scanner = new Scanner(System.in);
            System.out.print("请输入顶点个数: ");
            int vertices = scanner.nextInt();

            int[][] graph = new int[vertices][vertices];

            System.out.print("请输入边的个数: ");
            int edges = scanner.nextInt();

            System.out.println("请输入每条边的权重: ");
            for (int i = 0; i < edges; i++) {
                System.out.print("请输入"+(i+1)+"条边的起点: ");
                int source = scanner.nextInt();
                System.out.print("请输入"+(i+1)+"条边的终点: ");
                int destination = scanner.nextInt();
                System.out.print("请输入"+(i+1)+"条边的权重: ");
                int weight = scanner.nextInt();
                graph[source][destination] = weight;
                graph[destination][source] = weight;
            }

            int maxMatching = HungarianAlgorithm.maxMatching(graph);
            System.out.println("匈牙利算法的最大匹配为 : " + maxMatching);
            maxMatching = HopcroftKarpAlgorithm.maxMatching(graph);
            System.out.println("霍普克洛夫特－卡普算法的最大匹配为 : " + maxMatching);
            KruskalAlgorithm.V = vertices;
            System.out.println("克鲁斯卡尔算法生成的最小生成树结果为");
            KruskalAlgorithm.kruskal(graph);
            PrimAlgorithm.V = vertices;
            System.out.println("普里姆算法生成的最小生成树结果为");
            PrimAlgorithm.primMST(graph);

            int startVertex = 0;
            System.out.println("贝尔曼-福特算法生成的最短路径结果为");
            BellmanFordAlgorithm.bellmanFord(graph, startVertex);
            System.out.println("迪杰斯特拉算法生成的最短路径结果为");
            DijkstraAlgorithm.dijkstra(graph, startVertex);
         */
        }

}
